//! Utilities for connecting interrupts with asynchronous code (futures).

#![allow(dead_code)]

use core::cell::UnsafeCell;
use core::future::Future;
use core::pin::Pin;
use core::sync::atomic::{AtomicUsize, Ordering};
use core::task::{Context, Poll, Waker};

use atomic_refcell::AtomicRefCell;
use critical_section::{CriticalSection, Mutex};
use crossbeam::queue::ArrayQueue;

/// This trait is utilized by interrupts to pass information to a corresponding future.
pub trait InterruptWakerCore: Sized {
    /// The input provided by the interrupt handler.
    type InterruptInput;
    /// The output generated by the stream of inputs.
    type Output;

    /// Takes the future corresponding to this core.
    ///
    /// The implementation should return the future once and None afterwards. While it wouldn't
    /// to prevent race conditions. Note that a faulty implementation is not unsafe.
    fn take_future(&self) -> Option<InterruptFuture<Self>>;

    /// Process the value in `input`.
    fn update(&self, input: Self::InterruptInput);

    /// Returns the next processed value (if ready).
    fn take_next_value(&self) -> Option<Self::Output>;

    /// Updates this core's waker.
    ///
    /// A `CriticalSection` token is required to guarantee absence of data races between setting
    /// the waker and attempting to awake the future (from the interrupt).
    fn set_waker(&self, waker: Waker, cs: CriticalSection);

    /// Wakes up the future associated with this core.
    ///
    /// As with `set_waker`, a `CriticalSection` token is required.
    fn wake(&self, cs: CriticalSection);

    /// Performs an `update` followed by a `wake`.
    fn update_and_wake(&self, input: Self::InterruptInput, cs: CriticalSection) {
        self.update(input);
        self.wake(cs);
    }
}

/// An future type which is associated with an instance of an `InterruptCore`.
#[derive(Debug)]
pub struct InterruptFuture<'a, T: InterruptWakerCore> {
    core: &'a T,
}

impl<'a, T: InterruptWakerCore> InterruptFuture<'a, T> {
    /// Construct an `InterruptFuture` from the reference to the `core`.
    pub fn new(core: &'a T) -> Self {
        Self { core }
    }
}

impl<O, T: InterruptWakerCore<Output = O>> InterruptFuture<'_, T> {
    /// Asynchronously fetch the next interrupt output.
    pub async fn next(&mut self) -> O {
        self.await
    }
}

impl<O, T: InterruptWakerCore<Output = O>> Future for InterruptFuture<'_, T> {
    type Output = O;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if let Some(value) = self.core.take_next_value() {
            Poll::Ready(value)
        } else {
            critical_section::with(|cs| {
                self.core.set_waker(cx.waker().clone(), cs);
                Poll::Pending
            })
        }
    }
}

#[derive(Debug)]
struct UniqueHandle {}

/// An implementation of an `InterruptCore` that uses an atomic bounded buffer to directly pass
/// an interrupt input to the future.
#[derive(Debug)]
pub struct BoundedBufferInterrupt<T> {
    buffer: ArrayQueue<T>,
    waker: Mutex<UnsafeCell<Option<Waker>>>,
    future_handle: AtomicRefCell<Option<UniqueHandle>>,
}

impl<T> BoundedBufferInterrupt<T> {
    /// Construct the `BoundedBufferInterrupt` with the provided capacity.
    ///
    /// Note that this function allocates.
    pub fn new(buffer_size: usize) -> Self {
        Self {
            buffer: ArrayQueue::new(buffer_size),
            waker: Mutex::new(UnsafeCell::new(None)),
            future_handle: AtomicRefCell::new(Some(UniqueHandle {})),
        }
    }
}

impl<T> InterruptWakerCore for BoundedBufferInterrupt<T> {
    type InterruptInput = T;
    type Output = T;

    fn take_future(&self) -> Option<InterruptFuture<Self>> {
        self.future_handle.borrow_mut().take()?;
        Some(InterruptFuture::new(self))
    }

    fn update(&self, input: Self::InterruptInput) {
        // If the queue is full, we discard the oldest elements.
        let old = self.buffer.force_push(input);
        debug_assert!(old.is_none(), "Interrupt queue is full.");
    }

    fn set_waker(&self, waker: Waker, cs: CriticalSection) {
        // SAFETY: Mutex guarantees uninterrupted access. Aliasing is guaranteed because
        // waker isn't reborrowed down the stack.
        unsafe {
            *self.waker.borrow(cs).get() = Some(waker);
        }
    }

    fn take_next_value(&self) -> Option<Self::Output> {
        self.buffer.pop()
    }

    fn wake(&self, cs: CriticalSection) {
        // SAFETY: Mutex guarantees uninterrupted access. Aliasing is guaranteed because
        // waker isn't reborrowed down the stack.
        if let Some(waker) = unsafe { &mut *self.waker.borrow(cs).get() }.take() {
            waker.wake();
        }
    }
}

/// An implementation of `InterruptCore` that simply counts the number of interrupts it's received.
pub struct InterruptCounterCore {
    counter: AtomicUsize,
    waker: Mutex<UnsafeCell<Option<Waker>>>,
    future_handle: AtomicRefCell<Option<UniqueHandle>>,
}

impl InterruptCounterCore {
    /// Constrct the `InterruptCounterCore`.
    pub const fn new() -> Self {
        Self {
            counter: AtomicUsize::new(0),
            waker: Mutex::new(UnsafeCell::new(None)),
            future_handle: AtomicRefCell::new(Some(UniqueHandle {})),
        }
    }
}

impl InterruptWakerCore for InterruptCounterCore {
    type InterruptInput = ();
    type Output = usize;

    fn take_future(&self) -> Option<InterruptFuture<Self>> {
        self.future_handle.borrow_mut().take()?;
        Some(InterruptFuture::new(self))
    }

    fn update(&self, _input: ()) {
        self.counter.fetch_add(1, Ordering::Relaxed);
    }

    fn take_next_value(&self) -> Option<Self::Output> {
        let count = self.counter.swap(0, Ordering::Relaxed);
        if count > 0 {
            Some(count)
        } else {
            None
        }
    }

    fn set_waker(&self, waker: Waker, cs: CriticalSection) {
        // SAFETY: Mutex guarantees uninterrupted access. Aliasing is guaranteed because
        // waker isn't reborrowed down the stack.
        unsafe {
            *self.waker.borrow(cs).get() = Some(waker);
        }
    }

    fn wake(&self, cs: CriticalSection) {
        // SAFETY: Mutex guarantees uninterrupted access. Aliasing is guaranteed because
        // waker isn't reborrowed down the stack.
        if let Some(waker) = unsafe { &mut *self.waker.borrow(cs).get() }.take() {
            waker.wake();
        }
    }
}
